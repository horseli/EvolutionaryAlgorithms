//第二次修改 求最大值
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include<iostream>
#include<time.h>
using namespace std;

#define POPSIZE 100               /* population size */
#define MAXGENS 500             /* max. number of generations */
#define NVARS 2                 /* no. of problem variables */
#define PXOVER 0.7               /* probability of crossover */
#define PMUTATION 0.07           /* probability of mutation */
#define TRUE 1
#define FALSE 0

int generation;                  /* current generation no. */
int cur_best;

struct genotype /* genotype (GT), a member of the population */
{
	double gene[NVARS];        /* a string of variables */
	double fitness;            /* GT's fitness */
	double upper[NVARS];       /* GT's variables upper bound */
	double lower[NVARS];       /* GT's variables lower bound */
	double rfitness;           /* relative fitness */
	double cfitness;           /* cumulative fitness */
};
struct genotype population[POPSIZE + 1];    /* population */
struct genotype newpopulation[POPSIZE + 1]; /* new population; */
void initialize(void);
void initialize(void);double randval(double, double);void evaluate(void);void keep_the_best(void);void elitist(void);void select(void);void crossover(void);void Xover(int, int);void swap(double *, double *);void mutate(void);void report(void);void initialize(void){	int i, j;	double lbound, ubound;	remove("output.dat");	/* initialize variables within the bounds */	for (i = 0; i < NVARS; i++) {		lbound = -2;		ubound = 2;		for (j = 0; j < POPSIZE; j++) {			population[j].fitness = 0;			population[j].rfitness = 0;			population[j].cfitness = 0; 				population[j].lower[i] = lbound;			population[j].upper[i] = ubound;			population[j].gene[i] = randval(population[j].lower[i],				population[j].upper[i]);		}	}}double randval(double low, double high){	double val;	val = ((double)(rand() % 1000) / 1000.0)*(high - low) + low;	val = low + (high - low)*rand()*1.0 / RAND_MAX;//这个更好	return(val);}void evaluate(void){	int mem;	int i;	double x[NVARS + 1];	for (mem = 0; mem < POPSIZE; mem++)	{		for (i = 0; i < NVARS; i++)			x[i + 1] = population[mem].gene[i];		population[mem].fitness = x[1] * x[1] + x[2] * x[2];  //根据	}}void elitist(){	int i;  double best, worst;             /* best and worst fitness values */	int best_mem, worst_mem; /* indexes of the best and worst member */	best = population[0].fitness;  worst = population[0].fitness;	for (i = 0; i < POPSIZE - 1; ++i)	{		if (population[i].fitness > population[i + 1].fitness)		{			if (population[i].fitness >= best)   //越大越好			{				best = population[i].fitness;				best_mem = i;			}			if (population[i + 1].fitness <= worst)			{				worst = population[i + 1].fitness;				worst_mem = i + 1;			}		}		else		{			if (population[i].fitness <= worst)			{				worst = population[i].fitness;				worst_mem = i;			}			if (population[i + 1].fitness >= best)			{				best = population[i + 1].fitness;				best_mem = i + 1;			}		}	}	if (best >= population[POPSIZE].fitness)	{		for (i = 0; i < NVARS; i++)			population[POPSIZE].gene[i] = population[best_mem].gene[i];		population[POPSIZE].fitness = population[best_mem].fitness;	}	else	{		for (i = 0; i < NVARS; i++)			population[worst_mem].gene[i] = population[POPSIZE].gene[i];		population[worst_mem].fitness = population[POPSIZE].fitness;	}}	void select(void){	int mem, i, j, k; double sum = 0;  double p;	/* find total fitness of the population */	for (mem = 0; mem < POPSIZE; mem++)		sum += population[mem].fitness;	/* calculate relative fitness */	for (mem = 0; mem < POPSIZE; mem++)		population[mem].rfitness = population[mem].fitness / sum;	population[0].cfitness = population[0].rfitness;	/* calculate cumulative fitness */	for (mem = 1; mem < POPSIZE; mem++)	{		population[mem].cfitness = population[mem - 1].cfitness +			population[mem].rfitness;	}	/* finally select survivors using cumulative fitness. */	for (i = 0; i < POPSIZE; i++)	{		p = rand() % 1000 / 1000.0; // p=rand()*1.0/RAND_MAX;		if (p < population[0].cfitness)			newpopulation[i] = population[0];		else		{			for (j = 0; j < POPSIZE; j++)				if (p >= population[j].cfitness &&					p<population[j + 1].cfitness)					newpopulation[i] = population[j + 1];		}	}	/* once a new population is created, copy it back */	for (i = 0; i < POPSIZE; i++)		population[i] = newpopulation[i];}void crossover(void){	int i, mem, one;	int first = 0; /* count of the number of members chosen */	double x;	for (mem = 0; mem < POPSIZE; ++mem)	{		x = rand() % 1000 / 1000.0;		if (x < PXOVER)		{			++first;			if (first % 2 == 0)				Xover(one, mem);			else				one = mem;		}	}}void Xover(int one, int two){	int i;	int point; /* crossover point */			   /* select crossover point */	if (NVARS > 1)	{		if (NVARS == 2)			point = 1;		else			point = (rand() % (NVARS - 1)) + 1;		for (i = 0; i < point; i++)			swap(&population[one].gene[i], &population[two].gene[i]);	}}void swap(double *x, double *y){	double temp;	temp = *x;	*x = *y;	*y = temp;}void mutate(void){	int i, j;	double lbound, hbound;	double x;	for (i = 0; i < POPSIZE; i++)		for (j = 0; j < NVARS; j++)		{			x = rand() % 1000 / 1000.0;			if (x < PMUTATION)			{				/* find the bounds on the variable to be mutated */				lbound = population[i].lower[j];				hbound = population[i].upper[j];				population[i].gene[j] = randval(lbound, hbound);			}		}}void report(void){	int i;	double best_val;            /* best population fitness */	double avg;                 /* avg population fitness */	double stddev;              /* std. deviation of population fitness */	double sum_square;          /* sum of square for std. calc */	double square_sum;          /* square of sum for std. calc */	double sum;                 /* total population fitness */	sum = 0.0;	sum_square = 0.0;	for (i = 0; i < POPSIZE; i++)	{		sum += population[i].fitness;		sum_square += population[i].fitness * population[i].fitness;	}	avg = sum / (double)POPSIZE;	square_sum = avg * avg * POPSIZE;	stddev = sqrt((sum_square - square_sum) / (POPSIZE - 1));	best_val = population[POPSIZE].fitness;}void main(void){	srand(time(NULL)); //增加这么一句，以保证每次产生随机数的时候都不同	int i;	generation = 0;	initialize();	evaluate();	keep_the_best();	while (generation<MAXGENS)	{		generation++;		select();             //选择操作		crossover();       //交配操作		mutate();            //变异操作		report();		evaluate();		elitist();		cout << population[POPSIZE].fitness << endl;	}	}